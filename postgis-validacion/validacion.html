<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Validación &mdash; Curso de PostGIS 2.0 - PATHII, Tegucigalpa 2013 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Curso de PostGIS 2.0 - PATHII, Tegucigalpa 2013 1.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">Curso de PostGIS 2.0 - PATHII, Tegucigalpa 2013 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="validacion">
<h1>Validación<a class="headerlink" href="#validacion" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Fecha</th>
<th class="head">Autores</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1 Noviembre 2012</td>
<td><ul class="first last simple">
<li>Micho García (<a class="reference external" href="mailto:micho&#46;garcia&#37;&#52;&#48;geomati&#46;co">micho<span>&#46;</span>garcia<span>&#64;</span>geomati<span>&#46;</span>co</a>)</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>15 Octubre  2013</td>
<td><ul class="first last simple">
<li>Jorge Arévalo(<a class="reference external" href="mailto:jorge&#46;arevalo&#37;&#52;&#48;geomati&#46;co">jorge<span>&#46;</span>arevalo<span>&#64;</span>geomati<span>&#46;</span>co</a>)</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>1 Diciembre 2013</td>
<td><ul class="first last simple">
<li>Micho García (<a class="reference external" href="mailto:micho&#46;garcia&#37;&#52;&#48;geomati&#46;co">micho<span>&#46;</span>garcia<span>&#64;</span>geomati<span>&#46;</span>co</a>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>©2012 Micho García</p>
<p class="last">Excepto donde quede reflejado de otra manera, la presente documentación se halla bajo licencia : Creative Commons (Creative Commons - Attribution - Share Alike: <a class="reference external" href="http://creativecommons.org/licenses/by-sa/3.0/deed.es">http://creativecommons.org/licenses/by-sa/3.0/deed.es</a>)</p>
</div>
<div class="section" id="validar-geometrias">
<h2>Validar geometrías<a class="headerlink" href="#validar-geometrias" title="Permalink to this headline">¶</a></h2>
<p>Una operación común cuando se trabaja con datos vectoriales es validar que dichos datos cumplen ciertas condiciones que los hacen óptimos para realizar análisis espacial sobre los mismos. O de otra forma, que cumplen ciertas condiciones topológicas.</p>
<p>Los puntos y las líneas son objetos muy sencillos. Intuitivamente, podemos afirmar que no hay manera de que sean <em>topológicamente inválidos</em>. Pero un polígono es un objeto más complejo, y debería cumplir ciertas condiciones. Y debe cumplirlas porque muchos algoritmos espaciales son capaces de ejecutarse rápidamente gracias a que asumen una consistencias de los datos de entrada. Si tuviéramos que forzar a que esos algoritmos revisaran las entradas, serían mucho más lentos.</p>
<p>Veamos un ejemplo de porqué esto es importante. Supongamos que tenemos este polígono sencillo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># POLYGON((0 0, 0 1, 2 1, 2 2, 1 2, 1 0, 0 0));</span>
</pre></div>
</div>
<p>Gráficamente:</p>
<blockquote>
<div><a class="reference internal image-reference" href="../_images/poligono_invalido.png"><img alt="../_images/poligono_invalido.png" src="../_images/poligono_invalido.png" style="width: 174.5px; height: 163.0px;" /></a>
</div></blockquote>
<p>Podemos ver el límite exterior de esta figura como un símbolo de <em>infinito</em> cuadrado. O sea, que tiene un <em>lazo</em> en el medio (una intersección consigo mismo). Si quisiéramos calcular el área de esta figura, podemos ver intuitivamente que tiene 2 unidades de área (si hablamos de metros, serían 2 metros cuadrados).</p>
<p>Veamos qué piensa PostGIS del área de esta figura:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># SELECT ST_Area(ST_GeometryFromText(&#39;POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))&#39;));</span>
</pre></div>
</div>
<p>El resultado será:</p>
<div class="highlight-python"><pre># st_area
 ---------
0</pre>
</div>
<p>¿Qué es lo que ha sucedido aquí?</p>
<p>El algoritmo de cálculo de áreas de PostGIS (muy rápido) asume que los anillos no van a intersectar consigo mismos. Un anillo que cumpla las condiciones adecuadas para el análisis espacial, debe tener el área que encierra <strong>siempre</strong> en el mismo lado. Sin embargo, en la imagen mostrada, el anillo tiene, en una parte, el área encerrada en el lado izquierdo. Y en la otra, el área está encerrada en el lado derecho. Esto causa que las áreas calculadas para cada parte del polígono tengan valores opuestos (1 y -1) y se anulen entre si.</p>
<p>Este ejemplo es muy sencillo, porque podemos ver rápidamente que el polígono es inválido, al contener una intersección consigo mismo (algo que ESRI permite en un SHP, pero PostGIS no, porque implementa SFSQL: <a class="reference external" href="http://www.opengeospatial.org/standards/sfs">http://www.opengeospatial.org/standards/sfs</a>). Pero, ¿qué sucede si tenemos millones de polígonos? Necesitamos una manera de detectar si son válidos o inválidos. Afortunadamente, PostGIS tiene una función para esto: <strong>ST_IsValid</strong>, que devuelve TRUE o FALSE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># SELECT ST_IsValid(ST_GeometryFromText(&#39;POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))&#39;))</span>
</pre></div>
</div>
<p>Devuelve:</p>
<div class="highlight-python"><pre># st_isvalid
 ------------
         f</pre>
</div>
<p>Incluso tenemos una función que nos dice la razón por la que una geometría es inválida:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># SELECT ST_IsValidReason(ST_GeometryFromText(&#39;POLYGON((0 0, 0 1, 1 1, 2 1, 2 2, 1 2, 1 1, 1 0, 0 0))&#39;));</span>
</pre></div>
</div>
<p>Que devuelve:</p>
<div class="highlight-python"><pre># st_isvalidreason
------------------------
Self-intersection[1 1]</pre>
</div>
<p>Mediante el uso de la función <tt class="docutils literal"><span class="pre">st_isvaliddetail</span></tt> podremos obtener la información similar de las funciones anteriores de una sola llamada. Esta función dispone de la opción de no tener encuenta los anillos autointersectados que son permitidos en el modelo ESRI.</p>
</div>
<div class="section" id="diferencias-entre-el-modelo-esri-y-el-modelo-propuesto-por-ogc">
<h2>Diferencias entre el modelo ESRI y el modelo propuesto por OGC<a class="headerlink" href="#diferencias-entre-el-modelo-esri-y-el-modelo-propuesto-por-ogc" title="Permalink to this headline">¶</a></h2>
<p>Estas son algunas de las diferencias entre el modelo ESRI y el OGC:</p>
<ul class="simple">
<li>En el modelo ESRI los anillos de los polígonos tienen un sentido concreto mientras que en el OGC no.</li>
<li>ESRI no permite puntos repetidos, en OGC sí.</li>
<li>PostGIS permite geometrías nulas, ESRI no.</li>
<li>PostGIS permite geometrías vacías, mientras que ESRI no.</li>
<li>ESRI permite polígonos lazo</li>
</ul>
<p>Por lo que conviene realizar operaciones de validación de geometrías después de la exportación de datos de ESRI y antes de la importación de datos a ESRI:</p>
<p>Conviene realizar operaciones antes de intercambiar datos entre ambos modelos:</p>
<p>De PostGIS a ESRI:</p>
<ul class="simple">
<li>Eliminar geometrías nulas</li>
<li>Eliminar vértices repetidos</li>
<li>Eliminar geometrías vacías</li>
<li>Corregir geometrías no válidas</li>
</ul>
<p>De ESRI a PostGIS:</p>
<ul class="simple">
<li>Comprobar validez geometrías</li>
<li>Corregir no validez</li>
</ul>
<p>Por ejemplo, si tenemos la geometría:</p>
<div class="highlight-python"><pre>POLYGON ((20 30, 30 30, 30 20, 20 20, 20 30), (22 28, 28 28, 22 24.8, 28.1 22, 22 22, 22 28))</pre>
</div>
<p>y ejecutamos:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># select st_isvaliddetail(st_geomfromtext(&#39;POLYGON ((20 30, 30 30, 30 20, 20 20, 20 30), (22 28, 28 28, 22 24.8, 28.1 22, 22 22, 22 28))&#39;))</span>
</pre></div>
</div>
<p>obtendremos un valid_detail(valid, reason, location):</p>
<div class="highlight-python"><pre>(f,"Ring Self-intersection",01010000000000000000003640CDCCCCCCCCCC3840)</pre>
</div>
<p>si queremos acceder a cada una de los valores:</p>
<div class="highlight-python"><pre>valid((f,"Ring Self-intersection",01010000000000000000003640CDCCCCCCCCCC3840)) nos devolverá f</pre>
</div>
<p>Activando el &#8220;ESRI Flag&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># select st_isvaliddetail(st_geomfromtext(&#39;POLYGON ((20 30, 30 30, 30 20, 20 20, 20 30), (22 28, 28 28, 22 24.8, 28.1 22, 22 22, 22 28))&#39;), 1)</span>
</pre></div>
</div>
<p>el resultado será:</p>
<div class="highlight-python"><pre>(t,,)</pre>
</div>
<p>Esto es así porque mediante este flag, PostGIS marcará como válidos los polígonos con anillos que se encuentran autointersectados.</p>
<div class="section" id="practica">
<h3>Práctica<a class="headerlink" href="#practica" title="Permalink to this headline">¶</a></h3>
<div class="section" id="comprobar-el-funcionamiento-de-st-makevalid">
<h4>Comprobar el funcionamiento de ST_MakeValid<a class="headerlink" href="#comprobar-el-funcionamiento-de-st-makevalid" title="Permalink to this headline">¶</a></h4>
<p>Partiremos del polígono con forma de lazo mostrado anteriormente:</p>
<div class="highlight-python"><pre>POLYGON((0 0, 0 1, 2 1, 2 2, 1 2, 1 0, 0 0))</pre>
</div>
<p>Como vimos se trataba de una geometría no válida por lo que procederemos a su correción mediante el uso de la función <tt class="docutils literal"><span class="pre">ST_MakeValid</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># SELECT ST_AsText(ST_MakeValid(ST_GeomFromText(&#39;POLYGON((0 0, 0 1, 2 1, 2 2, 1 2, 1 0, 0 0))&#39;)));</span>
</pre></div>
</div>
<p>Que dará como resultado un MULTIPOLYGON:</p>
<div class="highlight-python"><pre>MULTIPOLYGON(((0 0,0 1,1 1,1 0,0 0)),((1 1,1 2,2 2,2 1,1 1)))</pre>
</div>
<p>Si quisiera mantener esta geometría en  mi tabla debería:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># SELECT (st_dump(ST_MakeValid(ST_GeomFromText(&#39;POLYGON((0 0, 0 1, 2 1, 2 2, 1 2, 1 0, 0 0))&#39;)))).geom</span>
</pre></div>
</div>
<p>Nos devolverá las geometrías tipo polígono.</p>
<p>En algunos casos el uso de la función <tt class="docutils literal"><span class="pre">ST_Buffer</span></tt> con valor 0 resuelve el problema de validez, pero podemos ver en este caso que esto a veces no es posible:</p>
<div class="highlight-python"><pre># SELECT ST_AsText(ST_buffer(ST_GeomFromText('POLYGON((0 0, 0 1, 2 1, 2 2, 1 2, 1 0, 0 0))'), 0));

POLYGON((1 1,1 2,2 2,2 1,1 1))</pre>
</div>
</div>
<div class="section" id="comprobar-como-el-uso-de-st-collect-genera-geometrias-no-validas">
<h4>Comprobar como el uso de ST_Collect genera geometrías no válidas<a class="headerlink" href="#comprobar-como-el-uso-de-st-collect-genera-geometrias-no-validas" title="Permalink to this headline">¶</a></h4>
<p>La función ST_Collect genera geometrías MULTI a partir de geometrías sencillas. Lo hace sin tener en cuenta la validez de la geometría resultado. Hay que recordar que para que una geometría MULTI sea válida, todas las geomtrías que la compongan deben ser válidas. Si tenemos dos geometrías que en origen son válidas:</p>
<div class="highlight-python"><pre>POLYGON ((0 2, 1 2, 1 1, 0 1, 0 2))'&amp; POLYGON ((0.5 1.5, 1.5 1.5, 1.5 0.5, 0.5 0.5, 0.5 1.5))</pre>
</div>
<p>Utilizando la función <tt class="docutils literal"><span class="pre">ST_Collect</span></tt> podremos generar una geometría inválida:</p>
<div class="highlight-python"><pre>#SELECT ST_isvaliddetail(ST_Collect(ST_GeomFromText('POLYGON ((0 2, 1 2, 1 1, 0 1, 0 2))'), ST_GeomFromText('POLYGON ((0.5 1.5, 1.5 1.5, 1.5 0.5, 0.5 0.5, 0.5 1.5))')))

(f,Self-intersection,0101000000000000000000F03F000000000000F83F)</pre>
</div>
<p>¿Qué pasaría si utilizase la función ST_MakeValid en este caso?.</p>
</div>
<div class="section" id="generar-una-restriccion-para-evitar-la-carga-de-geometrias-no-validas">
<h4>Generar una restricción para evitar la carga de geometrías no válidas<a class="headerlink" href="#generar-una-restriccion-para-evitar-la-carga-de-geometrias-no-validas" title="Permalink to this headline">¶</a></h4>
<p>Podemos evitar que se introduzcan datos no válidos en nuestras tablas simplemente mediante el uso de restricciones. Si creamos la siguiente tabla:</p>
<div class="highlight-python"><pre># CREATE TABLE gis.geometries
(
  gid serial NOT NULL,
  geom geometry(Polygon),
  CONSTRAINT pk_geometries PRIMARY KEY (gid )
)</pre>
</div>
<p>Añadiremos una restricción que no permita la inclusión de geometrías no válidas:</p>
<div class="highlight-python"><pre># ALTER TABLE gis.geometries
ADD CONSTRAINT geometry_valid_check
CHECK (ST_IsValid(geom));</pre>
</div>
<p>Al tratar de insertar un polígono no válido la restricción no lo permitirá:</p>
<div class="highlight-python"><pre># INSERT INTO gis.geometries (geom) VALUES (ST_GeomFromText('POLYGON((0 0, 0 1, 2 1, 2 2, 1 2, 1 0, 0 0))'));

NOTICE:  Self-intersection at or near point 1 1
ERROR:  new row for relation "geometries" violates check constraint "geometry_valid_check"

********** Error **********

ERROR: new row for relation "geometries" violates check constraint "geometry_valid_check"
SQL state: 23514</pre>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Estas restricciones pueden afectar a procesos de carga masivos mediante scripts.</p>
</div>
</div>
<div class="section" id="comprobar-la-validez-de-las-geometrias-del-shapefile-world-borders">
<h4>Comprobar la validez de las geometrías del shapefile <em>world_borders</em><a class="headerlink" href="#comprobar-la-validez-de-las-geometrias-del-shapefile-world-borders" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Puedes obtener los datos desde aquí[<a class="reference external" href="http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip">1</a>]</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># SELECT gid, name, ST_IsValidReason(geom) FROM tm_world_borders WHERE ST_IsValid(geom)=false;</span>
</pre></div>
</div>
<p>Obtenemos el resultado:</p>
<div class="highlight-python"><pre>#  gid |  name  |                  st_isvalidreason
  -----+--------+-----------------------------------------------------
    24 | Canada | Ring Self-intersection[-53.756367 48.5032620000001]
    33 | Chile  | Ring Self-intersection[-70.917236 -54.708618]
   155 | Norway | Ring Self-intersection[5.33694400000002 61.592773]
   175 | Russia | Ring Self-intersection[143.661926 49.31221]</pre>
</div>
<p>Observamos que hay 4 polígonos con intersecciones consigo mismos. Esto es un ejemplo del aspecto que tienen estas auto-intersecciones:</p>
<blockquote>
<div><a class="reference internal image-reference" href="../_images/self_intersection.png"><img alt="../_images/self_intersection.png" src="../_images/self_intersection.png" style="width: 286.0px; height: 183.0px;" /></a>
</div></blockquote>
<p>Para resolver estos errores topológicos, tenemos a nuestra disposición la función <em>ST_MakeValid</em>. Esta función es nueva en PostGIS 2.0. Hasta entonces, estos problemas se resolvían con técnicas como hacer un buffer de tamaño 0 alrededor de la geometría inválida, y dejar que la función <em>ST_Buffer</em> la arreglara. Esto es así porque <em>ST_Buffer</em> en realidad construye una nueva geometría réplica de la antigua y construyendo un buffer alrededor de ella. Si este buffer es de tamaño 0, el resultado es solo la réplica de la anterior geometría. Pero al ser construida siguiendo las reglas topológicas de OGC, solucionaba muchos problemas como éste.</p>
<p>La función <em>ST_MakeValid</em> es más apropiada para arreglar geometrías. Únicamente requiere <strong>GEOS 3.3.0</strong> o superior para funcionar (<strong>GEOS 3.3.4</strong>) si estamos usando PostGIS 2.1). Para saber qué versión de GEOS tenemos instalada basta con ejecutar:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># SELECT postgis_full_version()</span>
</pre></div>
</div>
<p>Si se tiene una versión de GEOS inferior a la 3.3.0, se pueden seguir los consejos de Paul Ramsey: <a class="reference external" href="http://blog.opengeo.org/2010/09/08/tips-for-the-postgis-power-user/">http://blog.opengeo.org/2010/09/08/tips-for-the-postgis-power-user/</a></p>
<p>Para comprobar el funcionamiento de <em>ST_MakeValid</em> vamos a crear una tabla nueva donde almacenemos únicamente uno de los polígonos conflictivos, marcado como <em>erroneo</em>. A continuación, crearemos un nuevo registro en dicha tabla con el polígono corregido.</p>
<p>Para hacerlo, ejecutemos esta query, que es algo compleja. Como sabemos que el problema es una auto-intersección que forma un anillo, vamos a <em>desmontar</em> la geometría en su lista de anillos y quedarnos solo con aquel que intersecta con el punto donde se detectó el error:</p>
<div class="highlight-python"><pre># SELECT * INTO invalid_geometries
FROM (
SELECT 'broken'::varchar(10) as status,
ST_GeometryN(geom, generate_series(1, ST_NRings(geom)))::geometry(Polygon,4326) as the_geom
FROM tm_world_borders
WHERE name = 'Chile') AS foo
WHERE ST_Intersects(the_geom, ST_SetSRID(ST_Point(-70.917236,-54.708618), 4326));</pre>
</div>
<p>Con eso hemos creado la tabla <em>invalid_geometries</em> y añadido el anillo que contiene el error. Ahora añadamos un nuevo registro con el resultado de llamar a <em>ST_MakeValid</em> sobre el polígono erróneo:</p>
<div class="highlight-python"><pre># INSERT INTO invalid_geometries
VALUES ('repaired', (SELECT ST_MakeValid(the_geom) FROM invalid_geometries));</pre>
</div>
<p>La función ST_MakeValid, realmente solo ha añadido un anillo más a la geometría inválida, para hacerla válida. Lo podemos comprobar con:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># SELECT status, ST_NRings(the_geom) FROM invalid_geometries;</span>
</pre></div>
</div>
<p>Que devuelve:</p>
<div class="highlight-python"><pre># status  | st_nrings
----------+-----------
broken   |         1
repaired |         2</pre>
</div>
<p>Ahora que ya hemos comprobado cómo funciona <em>ST_MakeValid</em>, podemos arreglar todas las geometrías inválidas:</p>
<div class="highlight-python"><pre># UPDATE tm_world_borders
SET the_geom = ST_MakeValid(the_geom)
WHERE ST_IsValid(the_geom) = false;</pre>
</div>
<p>Una manera de evitar tener tablas con geometrías inválidas es definir una <em>constraint</em> que lo impida:</p>
<div class="highlight-python"><pre># CREATE TABLE

# ALTER TABLE tm_world_borders
ADD CONSTRAINT geometry_valid_check
CHECK (ST_IsValid(geom));</pre>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Validación</a><ul>
<li><a class="reference internal" href="#validar-geometrias">Validar geometrías</a></li>
<li><a class="reference internal" href="#diferencias-entre-el-modelo-esri-y-el-modelo-propuesto-por-ogc">Diferencias entre el modelo ESRI y el modelo propuesto por OGC</a><ul>
<li><a class="reference internal" href="#practica">Práctica</a><ul>
<li><a class="reference internal" href="#comprobar-el-funcionamiento-de-st-makevalid">Comprobar el funcionamiento de ST_MakeValid</a></li>
<li><a class="reference internal" href="#comprobar-como-el-uso-de-st-collect-genera-geometrias-no-validas">Comprobar como el uso de ST_Collect genera geometrías no válidas</a></li>
<li><a class="reference internal" href="#generar-una-restriccion-para-evitar-la-carga-de-geometrias-no-validas">Generar una restricción para evitar la carga de geometrías no válidas</a></li>
<li><a class="reference internal" href="#comprobar-la-validez-de-las-geometrias-del-shapefile-world-borders">Comprobar la validez de las geometrías del shapefile <em>world_borders</em></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/postgis-validacion/validacion.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">Curso de PostGIS 2.0 - PATHII, Tegucigalpa 2013 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Micho García.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>